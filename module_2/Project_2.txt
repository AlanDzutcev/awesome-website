import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import combinations
from scipy.stats import ttest_ind
import numpy as np
from scipy.stats import t

pd.set_option('display.max_rows', 50) # показывать больше строк
pd.set_option('display.max_columns', 50) # показывать больше колонок

#1. Первичная обработка данных (включает анализ распределения признака для числовых данных, оценку уникальных значения для номинативных данных, выводы и тд.)

#Рассмотрим, какие данные хранятся в файле и какие типы данных у столбцов:

display(math.head(10))
math.info() 

# Теперь рассмотрим все столбцы по отдельности

# 1.1 school
# 1.1.1 Уникальные значения
math.school.value_counts()

# 1.2 sex
# 1.2.1 Уникальные значения
math.sex.value_counts()

# 1.3 age
# 1.3.1 Анализ распределения
math.age.hist()
math.age.describe()

# Распределение возраста без аномалий в интервале от 15 до 17ти лет (здравый смысл и опыт подсказывает, что это нормальный возраст для школьника).
# Вопрос выызвает наличие школьников от 18ти (не включая) и старше. Это либо выбросы(для этого проведем оценку),
# либо второгодники (выявить причину в условиях жизни),
# либо особенности какого-либо общего признака (образовательная система какой-страны)

# 1.3.2 Проверка на выбросы и отчистка дынных.

IQR = math.age.quantile(0.75) - math.age.quantile(0.25)
perc25 = math.age.quantile(0.25)
perc75 = math.age.quantile(0.75)

print(
    '25-й перцентиль: {},'.format(perc25),
    '75-й перцентиль: {},'.format(perc75),
    "IQR: {}, ".format(IQR),
    "Границы выбросов: [{f}, {l}].".format(f=perc25 - 1.5*IQR, l=perc75 + 1.5*IQR))

# Как мы видим, данные с возрастом более 21 года являются выбросом.
math = math.loc[math.age <= 21]

# 1.4 address (тип адреса ученика ('U' - городской, 'R' - за городом))
# 1.4.1 Уникальные значения
math.address.value_counts()

# 1.5 famsize (Размер семьи ('LE3' <= 3, 'GT3' >3))
# 1.5.1 Уникальные значения
math.famsize.value_counts()

# 1.6 Pstatus — статус совместного жилья родителей ('T' - живут вместе 'A' - раздельно)
# 1.6.1 Уникальные значения
math.Pstatus.value_counts()

# 1.7 Medu — образование матери (0 - нет, 1 - 4 класса, 2 - 5-9 классы, 3 - среднее специальное или 11 классов, 4 - высшее)
# 1.7.1 Анализ распределения
math.Medu.hist()

# 1.8 Fedu — образование отца (0 - нет, 1 - 4 класса, 2 - 5-9 классы, 3 - среднее специальное или 11 классов, 4 - высшее)
# 1.8.1 Анализ распределения
math.Fedu.hist()
# Обнаружен выброс "40" (ошибка при вводе данных). Давайте исключим его.
math = math.loc[math.Fedu != 40]

# В целом, процент мужчин без высшего образования больше чем у женщин. 
# Возможные причины:
# 1. Большой процент ранних браков (большое количество детей на семью). Мужчина идет работать до получения образования
# 2. Рабочая профессия приносит денег больше
# 3. Менталитет

# 1.9 Mjob — работа матери ('teacher' - учитель, 'health' - сфера здравоохранения, 'services' - гос служба, 'at_home' - не работает, 'other' - другое)
# 1.9.1 Уникальные значения
math.Mjob.value_counts()

# Если проссумировать health, teacher, serveces, то это вполне коллериует с количеством матерей с высшим образованием.

# 1.10 Fjob — работа отца ('teacher' - учитель, 'health' - сфера здравоохранения,'services' - гос служба, 'at_home' - не работает, 'other' - другое)
# 1.10.1 Уникальные значения
math.Fjob.value_counts()

# Большой процент в other вкупе с большим процентов отцов без высшего образования говорит о преимущественом выборе отцов рабочей профессии

# 1.12 guardian — опекун ('mother' - мать, 'father' - отец, 'other' - другое)
# 1.12.1 Уникальные значения
math.guardian.value_counts()

# 1.14 studytime — время на учёбу помимо школы в неделю (1 - <2 часов, 2 - 2-5 часов, 3 - 5-10 часов, 4 - >10 часов)
# 1.14.1 Уникальные значения
math.studytime.value_counts()

# 1.15 failures — количество внеучебных неудач (n, если 1<=n<=3, иначе 0)
# 1.15.1 Уникальные значения
math.failures.value_counts()

# 1.16 schoolsup — дополнительная образовательная поддержка (yes или no)
# 1.16.1 Уникальные значения
math.schoolsup.value_counts()

# 1.17 famsup — семейная образовательная поддержка (yes или no)
# 1.17.1 Уникальные значения
math.famsup.value_counts()

# 1.18 paid — дополнительные платные занятия по математике (yes или no)
# 1.18.1 Уникальные значения
math.paid.value_counts()

# 1.19 activities — дополнительные внеучебные занятия (yes или no)
# 1.19.1 Уникальные значения
math.activities.value_counts()

# 1.20 nursery — посещал детский сад (yes или no)
# 1.20.1 Уникальные значения
math.nursery.value_counts()

# 1.21 higher — хочет получить высшее образование (yes или no)
# 1.21.1 Уникальные значения
math.higher.value_counts()

# 1.22 internet — наличие интернета дома (yes или no)
# 1.22.1 Уникальные значения
math.internet.value_counts()

# 1.23 romantic — в романтических отношениях (yes или no)
# 1.23.1 Уникальные значения
math.romantic.value_counts()

# 1.24 famrel — семейные отношения (от 1 - очень плохо до 5 - очень хорошо)
# 1.24.1 Уникальные значения
math.famrel.value_counts()
# Обнаружен выброс "-1". Давайте исключим его
math = math.loc[math.famrel != -1]

# 1.25 freetime — свободное время после школы (от 1 - очень мало до 5 - очень мого)
# 1.25.1 Уникальные значения
math.freetime.value_counts()

# 1.26 goout — проведение времени с друзьями (от 1 - очень мало до 5 - очень много)
# 1.26.1 Уникальные значения
math.goout.value_counts()

# 1.27 health — текущее состояние здоровья (от 1 - очень плохо до 5 - очень хорошо)
# 1.27.1 Уникальные значения
math.health.value_counts()

# 1.28 absences — количество пропущенных занятий
# 1.28.1 Уникальные значения
math.absences.value_counts()
math.absences.describe()

# 1.28.2 Проверка на выбросы и отчистка дынных.
IQR = math.absences.quantile(0.75) - math.absences.quantile(0.25)
perc25 = math.absences.quantile(0.25)
perc75 = math.absences.quantile(0.75)
print(
    '25-й перцентиль: {},'.format(perc25),
    '75-й перцентиль: {},'.format(perc75),
    "IQR: {}, ".format(IQR),
    "Границы выбросов: [{f}, {l}].".format(f=perc25 - 1.5*IQR, l=perc75 + 1.5*IQR))

# Исключим из выбросы (больше 20)
b = {22, 25, 54, 385, 26, 56, 24, 212, 21, 75, 30, 38, 40, 23, 28}
for i in b:
    math = math.loc[math.absences != i]
	
# 1.29 score — баллы по госэкзамену по математике
# 1.29.1 Уникальные значения
math.score.hist()
math.score.describe()

# 1.29.2 Проверка на выбросы и отчистка дынных.
IQR = math.score.quantile(0.75) - math.score.quantile(0.25)
perc25 = math.score.quantile(0.25)
perc75 = math.score.quantile(0.75)
print(
    '25-й перцентиль: {},'.format(perc25),
    '75-й перцентиль: {},'.format(perc75),
    "IQR: {}, ".format(IQR),
    "Границы выбросов: [{f}, {l}].".format(f=perc25 - 1.5*IQR, l=perc75 + 1.5*IQR))
# Выбросов нет, распределение близкое к нормальному

# Разберемся с нулями к колонке score
a = math.loc[math.score == 0]
a

# После изучения таблицы сделаем несколько выводов:
# 1. Значение score равно '0' и соответствующее ему значение absences так же равно "0", что мало похоже на правду.
# 2. Распределение признаков в массиве (skore = 0) примерно повторяет отношение распределения (визуальный осмотр) признаков основного массива, что
# позволяет сделать вывод об отсутствии особого признака отвечающего за score = 0. 
# 3. Значения score = 0 противоречат почти нормальному распределению score (что тоже мало похоже на правду)
# На основании этих пунктов мы можем удалить все строки содирежищие score = 0

math = math.loc[math.score != 0]

# Так как score это целевая величина, то для корректного построения модели необходимо удалисть все строки со NaN

math = math.dropna(subset=['score'], axis=0)

# 2 Корреляционный анализ для числовых значений

correlation = math.corr()
plt.subplots(figsize=(20, 15))
plt.xticks(rotation=45)
sns.heatmap(correlation, annot=True, cmap='coolwarm')

# 2.1 Анализ наличия статистически значимых коэффициентов
# Для того, чтобы отобрать правильные столбцы с числовыми признаками воспользуемся формулой нахождения значимости коэффициента корреляции, 
# a полученное значение сравним со значением Стьюдента (Tst) для коэффициента даверия 0.05 и n = 332. Не будем учитывать ,что для разным признаков
# будет разное количество значения n (за счет наличия NaN), так как это вносит незначительные измененния в итоговый коэффициент.

Tst = t.ppf(0.95, 332)

j = -1
for i in correlation.score:
    P = 332**0.5 / (1 - i**2)*i
    j += 1
    if abs(P) > x:
        print('коэффициента корреляции для ',
              correlation.columns[j], ' статистически значим.')
    else:
        print('коэффициента корреляции для ',
              correlation.columns[j], ' статистически не значим.')

# Коэффециент коррелляции межде Fedu и Medu достаточно высок для того, чтобы принимать только один для модели
# В итоге, для последующих операций оставляем: age, Medu, studytime , failures, goout , absences

# 3 Анализ номинативных значений

# Выделим колонки с номинативными значения в отдельный список
list_object = list()
for col in math.columns:
    if math.loc[:, col].dtype == 'O':
        col = str(col)
        list_object.append(col)
		
def get_boxplot(column):
    fig, ax = plt.subplots(figsize=(3, 4))
    sns.boxplot(x=math[column], y='score', data=math)
    plt.xticks(rotation=45)
    ax.set_title('Boxplot for ' + column)
    plt.show()

# Построим boxplot для всех признаков
for col in list_object:
    get_boxplot(col)
	
# Однако графики являются лишь вспомогательным инструментом, настоящую значимость различий может помочь распознать статистика.
# Проверим, есть ли статистическая разница в распределении оценок по номинативным признакам, с помощью теста Стьюдента.
# Проверим нулевую гипотезу о том, что распределения оценок батончиков по различным параметрам неразличимы:

def get_stat_dif(column):
    cols = math.loc[:, column].value_counts().index[:10]
    combinations_all = list(combinations(cols, 2))
    for comb in combinations_all:
        if ttest_ind(math.loc[math.loc[:, column] == comb[0], 'score'].dropna(),
                     math.loc[math.loc[:, column] == comb[1], 'score'].dropna()).pvalue \
                <= 0.05/len(combinations_all):  # Учли поправку Бонферони
            print('Найдены статистически значимые различия для колонки', column)
            break
			
for col in list_object:
    get_stat_dif(col)
	
# Как мы видим, серьёзно отличаются четыре параметра: sex,  address и  Mjob, schoolsup.
# Оставим эти переменные в датасете для дальнейшего построения модели

# 4 Выводы
# Итак, в нашем случае важные переменные, которые, возможно, оказывают влияние на оценку,
# это: age, Medu, studytime , failures, goout , absences , sex,  address и  Mjob, schoolsup.

math_for_model = math.loc[:, ['age', 'Medu', 'studytime', 'failures',
                              'goout', 'absences', 'sex', 'address', 'Mjob', 'schoolsup']]
math_for_model.describe()

# Итак, в результате EDA для анализа влияния условий жизни учеников на их успеваемость по математике были получены следующие выводы:
# 1. В данных достаточно мало пустых значений.
# 2. Выбросы найдены в малом количестве в некоторых столбах, однако их оказалось достаточно в целевом score. Их наличие в таком количестве говоритч о том, что данные недостаточно чистые.
# 3. Анализ корреляционных коэффициентов:
#     3.1 Обратная к. между age и score, намекает на падение заинтересованности с возрастом (плюс прямая к. между age и absences). Возможно это из за снижения контроля со стороны родителей
#     3.2 Обратная к. между failures и score говорит о немалом влиянии психологического настроя ученика на его успеваемость.
#     3.3 Score/Medu/Fedu (1/0.21/0.127) вкупе с предыдущим выводом (п. 1.8) намекает на большую роль матери в обучении ребенка.
#     3.4 Более высокое значение средних коэффициентов к. "психологических" параметров (age, failures, Medu) в сравнении с "временными" (studitime, goout)
#         намекает на большее влияние собственного настроя ученика на учебу.
# 4. Вопросы к номинативным значениям
#     4.1 Подозрительным кажется обратная обратная зависимость межде schoolsup и score (здравый смысл говорит о другом). Не может ли это быть ощибкой (вопрос к ментору)?
#     4.2 Вопрос к ментору: Почему при явной графической зависимости (higher и internet) они не оказались статистически значимыми? При этом другие величины, 
#         даже при меньшем графическом отличии, оказались значимыми.  
# 5. Самые важные параметры, которые предлагается использовать в дальнейшем для построения модели, это 'age', 'Medu', 'studytime', 'failures',
                              'goout', 'absences', 'sex', 'address', 'Mjob', 'schoolsup'.






















